# Plot relative forecasted MES of the ERC portfolio
eps <- 0.01
ggplot(res_appl) +
# geom_line(aes(x=Date, y=w, col=Asset)) +
geom_hline(yintercept=c(1/m-eps, 1/m+eps)) +
geom_point(aes(x=Date, y=MES_rel, col=Asset))
###  Show performance!
df_performance %>%
group_by(Asset) %>%
summarize(mean=mean(-LogLosses),
sd=sd(-LogLosses),
VaR=quantile(-LogLosses, 0.05),
ES=mean(-LogLosses[-LogLosses < VaR]),
SharpR=mean/sd,
RORAC=mean/-ES) %>%
arrange(desc(RORAC))
# Plot portfolio performance
ggplot(df_performance) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(0.5,5))
# Plot portfolio performance
ggplot(df_performance) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(0.5,5)) +
xlim(c("2020-01-01", "2020-05-31"))
ggplot(df_performance %>% filter(Date %in% c("2020-01-01", "2020-05-31"))) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(0.5,5))
# Plot portfolio performance
ggplot(df_performance %>% filter(Date >= "2020-01-01", Date <= "2020-05-31"))) +
# Plot portfolio performance
ggplot(df_performance %>% filter(Date >= "2020-01-01", Date <= "2020-05-31")) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(0.5,5))
# Plot portfolio performance
ggplot(df_performance %>% filter(Date >= "2020-01-01", Date <= "2020-05-31")) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(1.5,6))
# Plot portfolio performance
ggplot(df_performance %>% filter(Date >= "2023-01-01", Date <= "2023-05-31")) +
geom_line(aes(x=Date, y=Price_rel, col=Asset, linetype=type_Asset)) +
ylim(c(1.5,6))
df_performance
res_appl$iterations
# Plot ERC portfolio weights
ggplot(res_appl) +
geom_line(aes(x=Date, y=w_stacked, col=Asset), linetype="dashed") +
geom_smooth(aes(x=Date, y=w_stacked, col=Asset))
res_appl
# Plot ERC portfolio weights
ggplot(res_appl) +
geom_line(aes(x=Date, y=w_stacked, col=Asset), linetype="dashed") +
geom_smooth(aes(x=Date, y=w_stacked, col=Asset)) +
geom_point(data=res_appl %>% group_by(Date) %>% summarize(iterations=mean(iterations)), aes(x=Date, y=iterations/50))
# Plot relative forecasted MES of the ERC portfolio
eps <- 0.01
ggplot(res_appl) +
# geom_line(aes(x=Date, y=w, col=Asset)) +
geom_hline(yintercept=c(1/m-eps, 1/m+eps)) +
geom_point(aes(x=Date, y=MES_rel, col=Asset)) +
geom_point(data=res_appl %>% group_by(Date) %>% summarize(iterations=mean(iterations)), aes(x=Date, y=iterations/50))
# Plot relative forecasted MES of the ERC portfolio
eps <- 0.01
ggplot(res_appl) +
# geom_line(aes(x=Date, y=w, col=Asset)) +
geom_hline(yintercept=c(1/m-eps, 1/m+eps)) +
geom_point(aes(x=Date, y=MES_rel, col=Asset)) +
geom_point(data=res_appl %>% group_by(Date) %>% summarize(iterations=mean(iterations)), aes(x=Date, y=(iterations==50)))
# Plot relative forecasted MES of the ERC portfolio
eps <- 0.01
ggplot(res_appl) +
# geom_line(aes(x=Date, y=w, col=Asset)) +
geom_hline(yintercept=c(1/m-eps, 1/m+eps)) +
geom_point(aes(x=Date, y=MES_rel, col=Asset)) +
geom_point(data=res_appl %>% group_by(Date) %>% summarize(iterations=mean(iterations)), aes(x=Date, y=as.numeric(iterations==50)))
eps <- 0.01
ggplot(res_appl) +
# geom_line(aes(x=Date, y=w, col=Asset)) +
geom_hline(yintercept=c(1/m-eps, 1/m+eps)) +
geom_point(aes(x=Date, y=MES_rel, col=Asset)) +
geom_point(data=res_appl %>% group_by(Date) %>% summarize(iterations=mean(iterations)), aes(x=Date, y=as.numeric(iterations==50)/m))
SRM
library(devtools)
library(roxygen2)
load_all()
document()
library(SystemicRisk)
MES_tdist
library(MASS)
library(dplyr)
library(tibble)
library(ggplot2)
library(doParallel)
library(MTS)
library(tsibble)
library(SystemicRisk)
# LoadDGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# Preliminary settings
M <- 50
optim_replications <- c(1,3)
n_set <- c(1000, 2000, 4000)
prob_level_list <- list(c(beta=0.9, alpha=0.5),
c(beta=0.95, alpha=0.5),
c(beta=0.99, alpha=0.5))
# prob_level_list <- list(c(beta=0.9, alpha=0.5))
risk_measure_set <- c("MES")
model_set <- c("lin_4p", "lin_6p")
# model_set <- c("lin_4p")
gamma_list <- list(c(1, 1.5, 0, 0.25, 0.5, 0),
c(1, 1.5, 2, 0.25, 1, 0))
sigma1 <- 2
sigma2 <- 1
rho <- 0.5
Sigma2 <- matrix(c(sigma1^2, rho*sigma1*sigma2, rho*sigma1*sigma2, sigma2^2), nrow=2) # Covariance matrix
Sigma <- t(chol(Sigma2)) # Square-root of Covariance matrix
phi <- c(0.5, 0.8)
nu <- 8
# Cluster Settings
core.max <- 10
cl <- makeCluster(min(parallel::detectCores()-1, M, core.max) )
registerDoParallel(cl)
start.time <- Sys.time()
res_df_MC <- foreach(
i_MC = 1:M,
.combine=rbind,
.packages=c("dplyr", "tibble", "MTS", "MASS", "mvtnorm", "cubature", "rmgarch", "lubridate", "abind", "tsibble", "SystemicRisk"),
.errorhandling="pass"
)%dopar%{
set.seed(i_MC) # set seed for reproducibility
res_df <- tibble()
# Load CoQR DGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# # Package functions
# source("R/CoQR.R")
# source("R/CoVaR_cov.R")
# source("R/model_functions.R")
# source("R/utils.R")
for (model in model_set){
for (n in n_set){
for (prob_level in prob_level_list){
beta <- prob_level[[1]]
alpha <- prob_level[[2]]
# Simulate data
gamma <- switch(model,
lin_4p = {gamma_list[[1]]},
lin_6p = {gamma_list[[2]]})
sim_help <- sim_SRM_DGP(n=n, gamma=gamma, Sigma=Sigma, nu=nu, phi=phi, beta=beta, alpha=alpha)
theta_true <- unlist(sim_help$theta_true[c("VaR",risk_measure)])
# Transform data to tsibble
data <- sim_help$data %>%
mutate(Date=1:n()) %>%
as_tsibble(index=Date)
for (risk_measure in risk_measure_set){
# Parameter estimate
if (model=="lin_4p"){
theta0 <- theta_true[-c(3,6)]
est_obj <- SRM(data = data %>% dplyr::select(-z3),
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else if (model=="lin_6p"){
theta0 <- theta_true
est_obj <- SRM(data=data,
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else {
stop("enter a correct model name!")
}
df_theta_est <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "param_est",
theta_index = 1:length(est_obj$theta),
value = est_obj$theta)
df_theta_true <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "true_value",
theta_index = 1:length(theta0),
value = theta0)
# Covariance estimation
sum_obj_asy <- summary(est_obj)
df_theta_cov_asy <-  data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "cov_est_asy",
theta_index = 1:length(MTS::Vech(sum_obj_asy$cov)),
value = MTS::Vech(sum_obj_asy$cov))
res_df <- rbind(res_df,
df_theta_est,
df_theta_true,
df_theta_cov_asy)
}
}
}
}
res_df
}
stopCluster(cl)
end.time <- Sys.time()
(run.time <- end.time-start.time)
head(res_df_MC)
saveRDS(res_df_MC, file = "playground/data/sim_crossDGP_20230404.rds")
library(MASS)
library(dplyr)
library(tibble)
library(ggplot2)
library(doParallel)
library(MTS)
library(tsibble)
library(SystemicRisk)
# LoadDGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# Preliminary settings
M <- 50
optim_replications <- c(1,3)
n_set <- c(1000, 2000, 4000)
prob_level_list <- list(c(beta=0.9, alpha=0.5),
c(beta=0.95, alpha=0.5),
c(beta=0.99, alpha=0.5))
# prob_level_list <- list(c(beta=0.9, alpha=0.5))
risk_measure_set <- c("MES")
model_set <- c("lin_4p", "lin_6p")
# model_set <- c("lin_4p")
gamma_list <- list(c(1, 1.5, 0, 0.25, 0.5, 0),
c(1, 1.5, 2, 0.25, 1, 0))
sigma1 <- 2
sigma2 <- 1
rho <- 0.5
Sigma2 <- matrix(c(sigma1^2, rho*sigma1*sigma2, rho*sigma1*sigma2, sigma2^2), nrow=2) # Covariance matrix
Sigma <- t(chol(Sigma2)) # Square-root of Covariance matrix
phi <- c(0.5, 0.8)
nu <- 8
i_MC = 1
set.seed(i_MC) # set seed for reproducibility
res_df <- tibble()
# Load CoQR DGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# # Package functions
# source("R/CoQR.R")
# source("R/CoVaR_cov.R")
# source("R/model_functions.R")
# source("R/utils.R")
model
for (model in model_set){
for (n in n_set){
for (prob_level in prob_level_list){
beta <- prob_level[[1]]
alpha <- prob_level[[2]]
# Simulate data
gamma <- switch(model,
lin_4p = {gamma_list[[1]]},
lin_6p = {gamma_list[[2]]})
sim_help <- sim_SRM_DGP(n=n, gamma=gamma, Sigma=Sigma, nu=nu, phi=phi, beta=beta, alpha=alpha)
theta_true <- unlist(sim_help$theta_true[c("VaR",risk_measure)])
# Transform data to tsibble
data <- sim_help$data %>%
mutate(Date=1:n()) %>%
as_tsibble(index=Date)
for (risk_measure in risk_measure_set){
# Parameter estimate
if (model=="lin_4p"){
theta0 <- theta_true[-c(3,6)]
est_obj <- SRM(data = data %>% dplyr::select(-z3),
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else if (model=="lin_6p"){
theta0 <- theta_true
est_obj <- SRM(data=data,
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else {
stop("enter a correct model name!")
}
df_theta_est <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "param_est",
theta_index = 1:length(est_obj$theta),
value = est_obj$theta)
df_theta_true <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "true_value",
theta_index = 1:length(theta0),
value = theta0)
# Covariance estimation
sum_obj_asy <- summary(est_obj)
df_theta_cov_asy <-  data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "cov_est_asy",
theta_index = 1:length(MTS::Vech(sum_obj_asy$cov)),
value = MTS::Vech(sum_obj_asy$cov))
res_df <- rbind(res_df,
df_theta_est,
df_theta_true,
df_theta_cov_asy)
}
}
}
}
theta0
sim_help
risk_measure
library(MASS)
library(dplyr)
library(tibble)
library(ggplot2)
library(doParallel)
library(MTS)
library(tsibble)
library(SystemicRisk)
# LoadDGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# Preliminary settings
M <- 50
optim_replications <- c(1,3)
n_set <- c(1000, 2000, 4000)
prob_level_list <- list(c(beta=0.9, alpha=0.5),
c(beta=0.95, alpha=0.5),
c(beta=0.99, alpha=0.5))
# prob_level_list <- list(c(beta=0.9, alpha=0.5))
risk_measure_set <- c("MES")
model_set <- c("lin_4p", "lin_6p")
# model_set <- c("lin_4p")
gamma_list <- list(c(1, 1.5, 0, 0.25, 0.5, 0),
c(1, 1.5, 2, 0.25, 1, 0))
sigma1 <- 2
sigma2 <- 1
rho <- 0.5
Sigma2 <- matrix(c(sigma1^2, rho*sigma1*sigma2, rho*sigma1*sigma2, sigma2^2), nrow=2) # Covariance matrix
Sigma <- t(chol(Sigma2)) # Square-root of Covariance matrix
phi <- c(0.5, 0.8)
nu <- 8
# Cluster Settings
core.max <- 10
cl <- makeCluster(min(parallel::detectCores()-1, M, core.max) )
registerDoParallel(cl)
start.time <- Sys.time()
res_df_MC <- foreach(
i_MC = 1:M,
.combine=rbind,
.packages=c("dplyr", "tibble", "MTS", "MASS", "mvtnorm", "cubature", "rmgarch", "lubridate", "abind", "tsibble", "SystemicRisk"),
.errorhandling="pass"
)%dopar%{
set.seed(i_MC) # set seed for reproducibility
res_df <- tibble()
# Load CoQR DGP function
source("playground/SRM_DGP.R")
# source("playground/GARCH_utils.R")
# # Package functions
# source("R/CoQR.R")
# source("R/CoVaR_cov.R")
# source("R/model_functions.R")
# source("R/utils.R")
for (model in model_set){
for (n in n_set){
for (prob_level in prob_level_list){
beta <- prob_level[[1]]
alpha <- prob_level[[2]]
# Simulate data
gamma <- switch(model,
lin_4p = {gamma_list[[1]]},
lin_6p = {gamma_list[[2]]})
sim_help <- sim_SRM_DGP(n=n, gamma=gamma, Sigma=Sigma, nu=nu, phi=phi, beta=beta, alpha=alpha)
# Transform data to tsibble
data <- sim_help$data %>%
mutate(Date=1:n()) %>%
as_tsibble(index=Date)
for (risk_measure in risk_measure_set){
# True parameter, depends on the risk_measure
theta_true <- unlist(sim_help$theta_true[c("VaR",risk_measure)])
# Parameter estimate
if (model=="lin_4p"){
theta0 <- theta_true[-c(3,6)]
est_obj <- SRM(data = data %>% dplyr::select(-z3),
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else if (model=="lin_6p"){
theta0 <- theta_true
est_obj <- SRM(data=data,
model="joint_linear", risk_measure=risk_measure, beta=beta, alpha=alpha, theta0=theta0, optim_replications=optim_replications)
} else {
stop("enter a correct model name!")
}
df_theta_est <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "param_est",
theta_index = 1:length(est_obj$theta),
value = est_obj$theta)
df_theta_true <- data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "true_value",
theta_index = 1:length(theta0),
value = theta0)
# Covariance estimation
sum_obj_asy <- summary(est_obj)
df_theta_cov_asy <-  data.frame(i_MC = i_MC,
model=model,
n=n,
alpha=alpha,
beta=beta,
risk_measure = risk_measure,
type = "cov_est_asy",
theta_index = 1:length(MTS::Vech(sum_obj_asy$cov)),
value = MTS::Vech(sum_obj_asy$cov))
res_df <- rbind(res_df,
df_theta_est,
df_theta_true,
df_theta_cov_asy)
}
}
}
}
res_df
}
stopCluster(cl)
end.time <- Sys.time()
(run.time <- end.time-start.time)
head(res_df_MC)
saveRDS(res_df_MC, file = "playground/data/sim_crossDGP_20230404.rds")
library(dplyr)
library(tidyr)
library(reshape2)
# library(CoQR)
# Load simulated data
res_df_MC <- readRDS(file = "playground/data/sim_crossDGP_20230404.rds")
# Set options
model_choice <- "lin_6p"
q1 <- 3
diag_entries <- which(MTS::Vech(diag(2*q1))==1)
# Estimated Covariance Matrix and standard deviations (diagonal covariance entries only) as data frames
res_MC_cov <- res_df_MC %>%
filter(model==model_choice, type %in% c("cov_est_asy")) %>%
group_by(theta_index, model, n, alpha, beta, risk_measure, type) %>%
summarize(theta_cov_mean = mean(value, na.rm = TRUE),
theta_cov_median = median(value, na.rm = TRUE))
res_MC_sd <- res_MC_cov %>%
filter(theta_index %in% diag_entries) %>%
group_by(model, n, alpha, beta, risk_measure) %>%
mutate(theta_index = 1:length(theta_index)) %>% # Reset theta index after selecting diagonal entries only
group_by(theta_index) %>%
mutate(sd_asy_mean = sqrt(theta_cov_mean),
sd_asy_median = sqrt(theta_cov_median))
# True parameter values
res_MC_true <- res_df_MC %>%
filter(model==model_choice, type=="true_value") %>%
group_by(theta_index, model, n, alpha, beta, risk_measure) %>%
summarize(theta_true = mean(value,na.rm = TRUE))
# Extract the mean parameter estimates
res_MC_est <- res_df_MC %>%
dplyr::filter(model==model_choice, type=="param_est") %>%
group_by(theta_index, model, n, alpha, beta, risk_measure) %>%
summarize(theta_mean = mean(value),
theta_median = median(value),
theta_sd_emp = sd(value)) %>%
ungroup()
# Join data frames together
res_MC <- res_MC_est %>%
left_join(res_MC_true,
by=c("theta_index", "model", "n", "alpha", "beta", "risk_measure")) %>%
left_join(res_MC_sd,
by=c("theta_index", "model", "n", "alpha", "beta", "risk_measure")) %>%
dplyr::select(theta_index, model, risk_measure, beta, alpha, n, theta_true, theta_mean, theta_median, theta_sd_emp, sd_asy_mean, sd_asy_median)
## Confidence interval coverage
res_MC_CI <- res_df_MC %>%
filter(model==model_choice, type %in% c("cov_est_asy")) %>%
group_by(i_MC, model, n, alpha, beta, risk_measure, type) %>%
filter(theta_index %in% diag_entries) %>%
mutate(theta_index=1:length(diag_entries)) %>% # This line is dangerous!
reshape2::dcast(i_MC + theta_index + model + n + alpha + beta + risk_measure ~ type) %>%
left_join(res_df_MC %>% dplyr::filter(type=="param_est") %>% select(-type) %>% rename(param_est = value),
by=c("i_MC", "theta_index", "model", "n", "alpha", "beta", "risk_measure")) %>%
mutate(CI_asy_lower = param_est - qnorm(0.975)*sqrt(cov_est_asy),
CI_asy_upper = param_est + qnorm(0.975)*sqrt(cov_est_asy)) %>%
left_join(res_df_MC %>% filter(type=="true_value") %>% select(-type) %>% rename(true_value = value),
by=c("i_MC", "theta_index", "model", "n", "alpha", "beta", "risk_measure")) %>%
as_tibble()
# Compute CI coverage
res_MC_CIcoverage <- res_MC_CI %>%
group_by(theta_index, model, n, alpha, beta, risk_measure) %>%
summarize(CI_asy_coverage = mean( (true_value >= CI_asy_lower) & (true_value <= CI_asy_upper)),
CI_asy_length = median(CI_asy_upper - CI_asy_lower))
# Look at specific results
res_MC %>% filter(n==2000) %>% arrange(beta)
